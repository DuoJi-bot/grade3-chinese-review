<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆè¯­è¡¥å…¨ç»ƒä¹  - ä¸‰å¹´çº§è¯­æ–‡å¤ä¹ </title>
    <link rel="stylesheet" href="../css/main.css">
</head>

<body>
    <div class="quiz-container">
        <!-- å¤´éƒ¨ -->
        <header class="quiz-header">
            <div class="quiz-back-btn" id="backBtn">
                <span>â†</span>
                <span>è¿”å›</span>
            </div>
            <h1 class="quiz-title" id="quizTitle">æˆè¯­è¡¥å…¨ç»ƒä¹ </h1>
            <div class="quiz-progress" id="progressText">- / -</div>
        </header>

        <!-- è¿›åº¦æ¡ -->
        <div class="progress-bar">
            <div class="progress-bar-fill" id="progressFill" style="width: 0%"></div>
        </div>

        <!-- é¢˜ç›®å†…å®¹åŒº -->
        <div class="quiz-content" id="quizContent">
            <div class="loading">
                <div class="loading-spinner"></div>
            </div>
        </div>

        <!-- å¯¼èˆªæŒ‰é’® -->
        <div class="nav-buttons">
            <button class="btn btn-primary" id="speakBtn">ğŸ”Š æœ—è¯»</button>
        </div>
    </div>

    <script src="../js/utils/tts.js"></script>
    <script src="../js/utils/storage.js"></script>
    <script src="../js/quiz-types/QuizBase.js"></script>
    <script>
        /**
         * æˆè¯­è¡¥å…¨é¢˜å‹
         * éšæœºéšè—æˆè¯­ä¸­çš„ä¸¤ä¸ªå­—ï¼Œå­¦ç”Ÿç‚¹å‡»é€‰å­—åŒºå¡«å……
         */
        class IdiomCompleteQuiz extends QuizBase {
            constructor(options) {
                super(options);
                this.currentIdiom = null;
                this.blanks = [];
                this.filledChars = [];
                this.charPool = [];
            }

            /**
             * åŠ è½½æ•°æ®
             */
            async loadData() {
                const dataKey = this.getUrlParam('data') || 'body_parts_idioms';
                const data = await this.fetchJson('../data/idioms.json');

                // æ ¹æ® dataKey æ‰¾åˆ°å¯¹åº”çš„æ•°æ®æ®µ
                const section = data.sections.find(s => s.id === dataKey);

                if (section && section.items) {
                    // è·å–å·²ç­”å¯¹çš„é¢˜ç›®åˆ—è¡¨
                    const correctQuestions = window.storage.getCorrectQuestions(this.moduleId);

                    // è¿‡æ»¤å·²ç­”å¯¹çš„é¢˜ç›®
                    const allQuestions = section.items.map(item => ({
                        idiom: item.idiom,
                        pinyin: item.pinyin,
                        example: item.example || ''
                    }));

                    this.questions = allQuestions.filter(q => !correctQuestions.includes(q.idiom));

                    // å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½å·²ç­”å¯¹ï¼Œæ˜¾ç¤ºå…¨éƒ¨å®Œæˆ
                    if (this.questions.length === 0) {
                        this.questions = allQuestions; // é‡æ–°åŠ è½½æ‰€æœ‰é¢˜ç›®ä¾›å¤ä¹ 
                        this.allCompleted = true;
                    }

                    // æ›´æ–°æ ‡é¢˜
                    document.getElementById('quizTitle').textContent = section.title;
                } else {
                    throw new Error('æœªæ‰¾åˆ°æ•°æ®');
                }
            }

            /**
             * ç”Ÿæˆé¢˜ç›®
             */
            generateQuestion() {
                const question = this.questions[this.currentIndex];
                const idiom = question.idiom;
                const chars = idiom.split('');

                // éšæœºé€‰æ‹©2ä¸ªä½ç½®éšè—
                const positions = [];
                while (positions.length < 2) {
                    const pos = Math.floor(Math.random() * chars.length);
                    if (!positions.includes(pos)) {
                        positions.push(pos);
                    }
                }
                positions.sort((a, b) => a - b);

                this.currentIdiom = idiom;
                this.blanks = positions;
                this.filledChars = [];

                // ç”Ÿæˆé€‰å­—æ±  - åŒ…å«æ­£ç¡®ç­”æ¡ˆå’Œå¹²æ‰°é¡¹
                const correctChars = positions.map(p => chars[p]);
                const distractors = this.generateDistractors(correctChars, 4);
                this.charPool = this.shuffle([...correctChars, ...distractors]);
            }

            /**
             * ç”Ÿæˆå¹²æ‰°å­—
             */
            generateDistractors(correctChars, count) {
                const allChars = 'å¤©åœ°äººå±±æ°´é£äº‘æœˆæ—¥æ˜ŸèŠ±è‰æœ¨é¸Ÿè™«é±¼é¾™è™é©¬ç‰›ç¾Šç‹—çŒ«é¸¡å¿ƒå£æ‰‹è¶³ç›®è€³çœ‰å¤´é¢èº«';
                const distractors = [];

                while (distractors.length < count) {
                    const char = allChars[Math.floor(Math.random() * allChars.length)];
                    if (!correctChars.includes(char) && !distractors.includes(char)) {
                        distractors.push(char);
                    }
                }

                return distractors;
            }

            /**
             * æ¸²æŸ“é¢˜ç›®
             */
            render() {
                this.generateQuestion();
                const question = this.questions[this.currentIndex];
                const chars = this.currentIdiom.split('');

                let idiomHtml = '<div class="idiom-display">';
                chars.forEach((char, index) => {
                    if (this.blanks.includes(index)) {
                        idiomHtml += `<div class="idiom-char blank" data-index="${index}" data-answer="${char}"></div>`;
                    } else {
                        idiomHtml += `<div class="idiom-char">${char}</div>`;
                    }
                });
                idiomHtml += '</div>';

                // æ‹¼éŸ³
                let pinyinHtml = '';
                if (question.pinyin) {
                    pinyinHtml = `<div class="pinyin-text" style="text-align: center; font-size: 1rem; color: var(--text-secondary); margin-bottom: 1rem;">${question.pinyin}</div>`;
                }

                // é€‰å­—åŒº
                let poolHtml = '<div class="char-pool">';
                this.charPool.forEach((char, index) => {
                    poolHtml += `<div class="char-item" data-char="${char}" data-pool-index="${index}">${char}</div>`;
                });
                poolHtml += '</div>';

                // æç¤º
                const hintHtml = '<p style="text-align: center; color: var(--text-muted); margin-top: 1rem; font-size: 0.875rem;">ç‚¹å‡»ä¸‹æ–¹çš„å­—å¡«å…¥ç©ºæ ¼ä¸­</p>';

                this.container.innerHTML = pinyinHtml + idiomHtml + poolHtml + hintHtml;

                // ç»‘å®šäº‹ä»¶
                this.bindEvents();
            }

            /**
             * ç»‘å®šäº‹ä»¶
             */
            bindEvents() {
                // é€‰å­—ç‚¹å‡»äº‹ä»¶
                const charItems = this.container.querySelectorAll('.char-item');
                charItems.forEach(item => {
                    item.addEventListener('click', () => this.onCharClick(item));
                });

                // å¯¼èˆªæŒ‰é’®
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());

                // æœ—è¯»æŒ‰é’®
                document.getElementById('speakBtn').addEventListener('click', () => {
                    this.speak(this.currentIdiom);
                });
            }

            /**
             * ç‚¹å‡»é€‰å­—
             */
            onCharClick(item) {
                if (item.classList.contains('used')) return;

                const char = item.dataset.char;

                // æ‰¾åˆ°ä¸‹ä¸€ä¸ªç©ºæ ¼
                const blankIndex = this.blanks[this.filledChars.length];
                if (blankIndex === undefined) return;

                const blankEl = this.container.querySelector(`.idiom-char[data-index="${blankIndex}"]`);
                const correctChar = blankEl.dataset.answer;

                // å¡«å…¥å­—ç¬¦
                blankEl.textContent = char;
                blankEl.classList.remove('blank');
                blankEl.classList.add('filled');

                // æ ‡è®°å·²ä½¿ç”¨
                item.classList.add('used');
                this.filledChars.push(char);

                // æ£€æŸ¥æ˜¯å¦æ­£ç¡®
                const isCorrect = char === correctChar;

                if (isCorrect) {
                    blankEl.classList.add('correct');
                } else {
                    blankEl.classList.add('wrong');
                }

                // æ£€æŸ¥æ˜¯å¦å®Œæˆ
                if (this.filledChars.length === this.blanks.length) {
                    this.checkComplete();
                }
            }

            /**
             * æ£€æŸ¥æ˜¯å¦å®Œæˆ
             */
            checkComplete() {
                const allCorrect = this.blanks.every((blankIndex, i) => {
                    const blankEl = this.container.querySelector(`.idiom-char[data-index="${blankIndex}"]`);
                    return blankEl.textContent === blankEl.dataset.answer;
                });

                if (allCorrect) {
                    this.showCorrectFeedback();
                    this.correctCount++;

                    // è®°å½•ç­”å¯¹çš„é¢˜ç›®
                    window.storage.markQuestionCorrect(this.moduleId, this.currentIdiom);

                    // æœ—è¯»æˆè¯­
                    setTimeout(() => {
                        this.speak(this.currentIdiom);
                    }, 300);

                    // æ— è®ºæœ—è¯»æ˜¯å¦æˆåŠŸï¼Œéƒ½åœ¨2ç§’åè·³è½¬ä¸‹ä¸€é¢˜
                    setTimeout(() => {
                        if (this.currentIndex < this.questions.length - 1) {
                            this.nextQuestion();
                        } else {
                            this.showComplete();
                        }
                    }, 2000);
                } else {
                    this.showWrongFeedback();
                    // æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆåè·³è½¬
                    setTimeout(() => {
                        this.blanks.forEach(blankIndex => {
                            const blankEl = this.container.querySelector(`.idiom-char[data-index="${blankIndex}"]`);
                            blankEl.textContent = blankEl.dataset.answer;
                            blankEl.classList.remove('wrong');
                            blankEl.classList.add('correct');
                        });

                        setTimeout(() => {
                            if (this.currentIndex < this.questions.length - 1) {
                                this.nextQuestion();
                            } else {
                                this.showComplete();
                            }
                        }, 1500);
                    }, 500);
                }
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            const quiz = new IdiomCompleteQuiz({
                moduleId: new URLSearchParams(window.location.search).get('id') || 'idiom-complete'
            });
            quiz.init();
        });
    </script>
</body>

</html>
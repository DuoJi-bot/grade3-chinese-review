<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åè¨€è°šè¯­å¡«ç©º - ä¸‰å¹´çº§è¯­æ–‡å¤ä¹ </title>
    <link rel="stylesheet" href="../css/main.css">
    <style>
        .proverb-card {
            text-align: center;
            padding: 2rem;
        }

        .proverb-content {
            font-size: 1.5rem;
            line-height: 2;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
        }

        .proverb-blank {
            display: inline-block;
            min-width: 60px;
            padding: 0.25rem 0.5rem;
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: 600;
            margin: 0 0.25rem;
        }

        .proverb-blank::before {
            content: '?';
            opacity: 0.3;
            font-size: 1.2rem;
        }

        .proverb-blank.filled {
            background: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            border-bottom: none;
        }

        .proverb-blank.filled::before {
            content: none;
        }

        .proverb-blank.correct {
            background: var(--success-color);
        }

        .proverb-blank.wrong {
            background: var(--error-color);
        }

        .proverb-meaning {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(16, 185, 129, 0.1);
            border-radius: var(--radius-lg);
            color: var(--success-color);
            font-size: 0.9rem;
            display: none;
        }

        .proverb-meaning.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .options-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .option-chip {
            padding: 0.75rem 1.5rem;
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-full);
            cursor: pointer;
            transition: all var(--transition-fast);
            font-size: 1rem;
        }

        .option-chip:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .option-chip.selected {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
        }

        .option-chip.used {
            opacity: 0.4;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="quiz-container">
        <header class="quiz-header">
            <div class="quiz-back-btn" id="backBtn">
                <span>â†</span>
                <span>è¿”å›</span>
            </div>
            <h1 class="quiz-title" id="quizTitle">åè¨€è°šè¯­å¡«ç©º</h1>
            <div class="quiz-progress" id="progressText">- / -</div>
        </header>

        <div class="progress-bar">
            <div class="progress-bar-fill" id="progressFill" style="width: 0%"></div>
        </div>

        <div class="quiz-content" id="quizContent">
            <div class="loading">
                <div class="loading-spinner"></div>
            </div>
        </div>

        <div class="nav-buttons">
            <button class="btn btn-outline" id="prevBtn">â† ä¸Šä¸€é¢˜</button>
            <button class="btn btn-primary" id="speakBtn">ğŸ”Š æœ—è¯»</button>
            <button class="btn btn-outline" id="nextBtn">ä¸‹ä¸€é¢˜ â†’</button>
        </div>
    </div>

    <script src="../js/utils/tts.js"></script>
    <script src="../js/utils/storage.js"></script>
    <script src="../js/quiz-types/QuizBase.js"></script>
    <script>
        class PoemFillQuiz extends QuizBase {
            constructor(options) {
                super(options);
                this.answered = false;
                this.currentProverb = null;
            }

            async loadData() {
                const dataKey = this.getUrlParam('data') || 'treating_people';
                const data = await this.fetchJson('../data/proverbs.json');

                const section = data.sections.find(s => s.id === dataKey);
                if (section) {
                    document.getElementById('quizTitle').textContent = section.title;
                    this.questions = section.items;
                }
            }

            render() {
                this.answered = false;
                const proverb = this.questions[this.currentIndex];
                this.currentProverb = proverb;

                // è§£æåè¨€ï¼Œæ‰¾å‡ºéœ€è¦å¡«ç©ºçš„éƒ¨åˆ†
                // æ ¼å¼ï¼šç”¨ä¸­æ–‡åœ†æ‹¬å·ï¼ˆï¼‰æ‹¬èµ·æ¥çš„éƒ¨åˆ†æ˜¯å¡«ç©ºå†…å®¹
                let content = proverb.text;
                let blanks = [];
                let options = [];

                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ‰€æœ‰ï¼ˆï¼‰å†…çš„å†…å®¹
                const blankRegex = /ï¼ˆ([^ï¼‰]+)ï¼‰/g;
                let match;
                while ((match = blankRegex.exec(content)) !== null) {
                    blanks.push(match[1]); // match[1]æ˜¯æ‹¬å·å†…çš„å†…å®¹
                }

                // å¦‚æœæ‰¾åˆ°å¡«ç©ºå†…å®¹
                if (blanks.length > 0) {
                    // å°†å¡«ç©ºå†…å®¹ä½œä¸ºæ­£ç¡®é€‰é¡¹
                    options = [...blanks];

                    // æ·»åŠ å¹²æ‰°é€‰é¡¹
                    const distractors = this.generateDistractors(blanks);
                    options = this.shuffle([...options, ...distractors]);
                }

                // æ›¿æ¢æ‰€æœ‰æ‹¬å·å†…å®¹ä¸ºç©ºç™½
                let displayContent = content.replace(/ï¼ˆ([^ï¼‰]+)ï¼‰/g, '<span class="proverb-blank" data-answer="$1"></span>');

                let html = `
                    <div class="proverb-card">
                        <div class="proverb-content">${displayContent}</div>
                        
                        <div class="options-grid">
                            ${options.map(opt => `
                                <div class="option-chip" data-value="${opt}">${opt}</div>
                            `).join('')}
                        </div>
                        
                        <div class="proverb-meaning" id="meaningArea">
                            ğŸ’¡ ${proverb.meaning || ''}
                        </div>
                    </div>
                `;

                this.container.innerHTML = html;
                this.bindEvents();
                this.updateNavButtons();
                this.updateProgress();
            }

            generateDistractors(correctAnswers) {
                // ä»å…¶ä»–åè¨€çš„æ‹¬å·å†…å®¹ä¸­è·å–å¹²æ‰°é€‰é¡¹
                const allBlanks = [];
                this.questions.forEach(q => {
                    const blankRegex = /ï¼ˆ([^ï¼‰]+)ï¼‰/g;
                    let match;
                    while ((match = blankRegex.exec(q.text)) !== null) {
                        allBlanks.push(match[1]);
                    }
                });

                // è¿‡æ»¤æ‰æ­£ç¡®ç­”æ¡ˆï¼Œéšæœºé€‰æ‹©å¹²æ‰°é¡¹
                const distractors = allBlanks.filter(b => !correctAnswers.includes(b));
                return this.shuffle(distractors).slice(0, 3);
            }

            bindEvents() {
                // åªç»‘å®šé€‰é¡¹ç‚¹å‡»äº‹ä»¶ï¼ˆæ¯æ¬¡renderéƒ½éœ€è¦é‡æ–°ç»‘å®šï¼Œå› ä¸ºé€‰é¡¹DOMæ˜¯æ–°åˆ›å»ºçš„ï¼‰
                const options = this.container.querySelectorAll('.option-chip');
                options.forEach(opt => {
                    opt.addEventListener('click', () => this.selectOption(opt));
                });
            }

            // å¯¼èˆªæŒ‰é’®äº‹ä»¶åªç»‘å®šä¸€æ¬¡ï¼ˆåœ¨initä¹‹åè°ƒç”¨ï¼‰
            bindNavEvents() {
                if (this._navBound) return; // é˜²æ­¢é‡å¤ç»‘å®š
                this._navBound = true;

                document.getElementById('prevBtn').addEventListener('click', () => this.prevQuestion());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextQuestion());
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());
                document.getElementById('speakBtn').addEventListener('click', () => {
                    this.speak(this.currentProverb.text);
                });
            }

            updateNavButtons() {
                document.getElementById('prevBtn').disabled = this.currentIndex === 0;
            }

            selectOption(optEl) {
                if (optEl.classList.contains('used')) return;

                const selected = optEl.dataset.value;
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœªå¡«çš„ç©ºç™½
                const blanks = this.container.querySelectorAll('.proverb-blank:not(.filled)');
                if (blanks.length === 0) return;

                const blank = blanks[0];
                const correct = blank.dataset.answer;

                blank.textContent = selected;
                blank.classList.add('filled');
                optEl.classList.add('used');

                if (selected === correct) {
                    blank.classList.add('correct');
                } else {
                    blank.classList.add('wrong');
                    // æ˜¾ç¤ºæ­£ç¡®ç­”æ¡ˆ
                    setTimeout(() => {
                        blank.textContent = correct;
                        blank.classList.remove('wrong');
                        blank.classList.add('correct');
                    }, 500);
                }

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¡«ç©ºéƒ½å·²å®Œæˆ
                const remainingBlanks = this.container.querySelectorAll('.proverb-blank:not(.filled)');
                if (remainingBlanks.length === 0) {
                    // æ‰€æœ‰å¡«ç©ºå·²å®Œæˆ
                    this.answered = true;

                    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨æ­£ç¡®
                    const allBlanks = this.container.querySelectorAll('.proverb-blank');
                    const allCorrect = Array.from(allBlanks).every(b => b.classList.contains('correct') && !b.classList.contains('wrong-answer'));

                    if (allCorrect) {
                        this.showCorrectFeedback();
                        // æ³¨æ„ï¼šshowCorrectFeedback() å·²ç»å¢åŠ äº† correctCountï¼Œä¸éœ€è¦å†æ‰‹åŠ¨å¢åŠ 
                    } else {
                        this.showWrongFeedback();
                    }

                    // æ˜¾ç¤ºé‡Šä¹‰
                    document.getElementById('meaningArea').classList.add('show');

                    // æœ—è¯»
                    this.speak(this.currentProverb.text);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const quiz = new PoemFillQuiz({
                moduleId: new URLSearchParams(window.location.search).get('id') || 'poem-fill'
            });
            quiz.init().then(() => {
                quiz.bindNavEvents(); // å¯¼èˆªæŒ‰é’®åªç»‘å®šä¸€æ¬¡
            });
        });
    </script>
</body>

</html>